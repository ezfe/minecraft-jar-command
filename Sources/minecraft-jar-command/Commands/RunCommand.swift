//
//  RunCommand.swift
//
//
//  Created by Ezekiel Elin on 11/21/20.
//

import Foundation
import MojangAuthentication
import ArgumentParser
import Common
import InstallationManager

struct RunCommand: ParsableCommand {
    static var configuration = CommandConfiguration(
        commandName: "run",
        abstract: "Run Minecraft"
    )
    
    @Option(help: "The Minecraft version to download")
    var version: String?
    
    @Option(help: "The directory to save assets and libraries to")
    var workingDirectory: String?
    
    @Option(help: "The directory to start the game in")
    var gameDirectory: String?
    
    @Flag(help: "Print out the new access token before running the game")
    var printAccessToken: Bool = false
    
    @Argument(help: """
        An access token can be obtained from a POST request to
        the Minecraft authentication system. Refer to wiki.vg
        for more information on the /authenticate endpoint:
        https://wiki.vg/Authentication#Authenticate

        You can also use the access token stored in launcher_profiles.json,
        a file generated by the regular Minecraft Launcher.
        """)
    var accessToken: String
    
    @Argument(help: """
        A client token can be obtained from a POST request to
        the Minecraft authentication system. Refer to wiki.vg
        for more information on the /authenticate endpoint:
        https://wiki.vg/Authentication#Authenticate

        You can also use the client token stored in launcher_profiles.json,
        a file generated by the regular Minecraft Launcher.
        """)
    var clientToken: String
    
    mutating func run() throws {
//        let auth = try AuthenticationManager.refresh(accessToken: accessToken, clientToken: clientToken)
        let auth = AuthResult(accessToken: accessToken, clientToken: clientToken, profile: Profile(name: "ezfe", id: "id123"))
        print("\n\n")
        print("swift run minecraft-jar-command \(auth.accessToken) \(auth.clientToken)")
        print("\n\n")
        
        // Get Version Manifest and Specific Entry
        let versionManifest = try VersionManifest.downloadManifest()
        let versionManifestEntry: VersionManifest.VersionMetadata
        if let userRequestedVersion = version {
            versionManifestEntry = try versionManifest.get(version: .custom(userRequestedVersion))
        } else {
            versionManifestEntry = try versionManifest.get(version: .release)
        }
        
        // Next thing...
        print("Downloading \(versionManifestEntry.id) package info")
        let versionManifestData = try retrieveData(url: versionManifestEntry.url)
        
        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
        jsonDecoder.dateDecodingStrategy = .iso8601
        
        let versionInfo = try jsonDecoder.decode(VersionPackage.self, from: versionManifestData)
        
        guard versionInfo.minimumLauncherVersion >= 21 else {
            print("Unfortunately, \(versionManifestEntry.id) isn't available from this utility")
            print("This utility is only tested with the latest version, and does not work with versions prior to 1.13")
            Main.exit()
        }
        
        let gameDirectory = self.gameDirectory != nil ? URL(fileURLWithPath: self.gameDirectory!) : nil
        
        let installationManager: InstallationManager
        if let workingDirectory = workingDirectory {
            installationManager = try InstallationManager(requestedDirectory: URL(fileURLWithPath: workingDirectory), gameDirectory: gameDirectory, versionInfo: versionInfo)
        } else {
            installationManager = try InstallationManager(gameDirectory: gameDirectory, versionInfo: versionInfo)
        }
        
        //        print("\n\nDownloading game files to: \(workingDirectory.path).\n\n>>>Press any key to continue")
        //        let _ = readLine()
        
        var clientJAR: URL! = nil
        let group = DispatchGroup()
        group.enter()
        installationManager.downloadJar { result in
            switch result {
                case .success(let jar):
                    clientJAR = jar
                    group.leave()
                case .failure(let error):
                    Main.exit(withError: error)
            }
        }
        group.wait()
        
        let assetsVersion = try downloadAssets(versionInfo: versionInfo, installationManager: installationManager)
        
        var libraries: [LibraryMetadata]! = nil
        group.enter()
        installationManager.downloadLibraries { result in
            switch result {
                case .success(let metadata):
                    libraries = metadata
                    group.leave()
                case .failure(let error):
                    Main.exit(withError: error)
            }
        }
        group.wait()
        
        try libraries.filter { $0.isNative }.forEach { libMetadata in
            let target = installationManager.nativesDirectory.appendingPathComponent(libMetadata.localURL.lastPathComponent)
            try FileManager.default.copyItem(at: libMetadata.localURL, to: target)
        }
        
        let librariesClassPath = libraries.map { $0.localURL.relativePath }.joined(separator: ":")
        let classPath = "\(librariesClassPath):\(clientJAR.relativePath)"
        
        let argumentProcessor = ArgumentProcessor(versionName: versionManifestEntry.id,
                                                  assetsVersion: assetsVersion,
                                                  installationManager: installationManager,
                                                  classPath: classPath,
                                                  authResults: auth)
        
        let jvmArgsStr = argumentProcessor.jvmArguments(versionInfo: versionInfo)
        let gameArgsString = argumentProcessor.gameArguments(versionInfo: versionInfo)
        
        let proc = Process()
        proc.executableURL = URL(fileURLWithPath: "/usr/bin/java")
        proc.arguments = [
            "-Xms1024M",
            "-Xmx1024M",
        ]
        proc.arguments?.append(contentsOf: jvmArgsStr)
        proc.arguments?.append(versionInfo.mainClass)
        proc.arguments?.append(contentsOf: gameArgsString)
        
        proc.currentDirectoryURL = installationManager.baseDirectory
        
        let pipe = Pipe()
        proc.standardOutput = pipe
        
        print("Starting game...")
        proc.launch()
        
        proc.waitUntilExit()
    }
}
