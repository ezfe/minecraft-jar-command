//
//  RunCommand.swift
//
//
//  Created by Ezekiel Elin on 11/21/20.
//

import Foundation
import MojangAuthentication
import ArgumentParser
import Common
import InstallationManager

struct RunCommand: ParsableCommand {
    static var configuration = CommandConfiguration(
        commandName: "run",
        abstract: "Run Minecraft"
    )
    
    @Option(help: "The Minecraft version to download")
    var version: String?
    
    @Option(help: "The directory to save assets and libraries to")
    var workingDirectory: String?
    
    @Option(help: "The directory to start the game in")
    var gameDirectory: String?
    
    /*
    @Flag(help: "Print out the new access token before running the game")
    var printAccessToken: Bool = false
    
    @Argument(help: """
        An access token can be obtained from a POST request to
        the Minecraft authentication system. Refer to wiki.vg
        for more information on the /authenticate endpoint:
        https://wiki.vg/Authentication#Authenticate

        You can also use the access token stored in launcher_profiles.json,
        a file generated by the regular Minecraft Launcher.
        """)
    var accessToken: String
    
    @Argument(help: """
        A client token can be obtained from a POST request to
        the Minecraft authentication system. Refer to wiki.vg
        for more information on the /authenticate endpoint:
        https://wiki.vg/Authentication#Authenticate

        You can also use the client token stored in launcher_profiles.json,
        a file generated by the regular Minecraft Launcher.
        """)
    var clientToken: String
     */
    
    mutating func run() throws {
        let defaults = UserDefaults.standard
        
        guard let accessToken = defaults.string(forKey: "accessToken") else {
            print("Please run the login command with the --save-credentials flag to save a new access token")
            Main.exit()
        }
        guard let clientToken = defaults.string(forKey: "clientToken") else {
            print("Please run the login command with the --save-credentials flag to save a new client token")
            Main.exit()
        }
        
        let auth = try AuthenticationManager.refresh(accessToken: accessToken, clientToken: clientToken)
        print("\n\n")
        print("./minecraft-jar-command \(auth.accessToken) \(auth.clientToken)")
        print("\n\n")
        
        let gameDirectory = self.gameDirectory != nil ? URL(fileURLWithPath: self.gameDirectory!) : nil
        
        let installationManager: InstallationManager
        if let workingDirectory = workingDirectory {
            installationManager = try InstallationManager(requestedDirectory: URL(fileURLWithPath: workingDirectory), gameDirectory: gameDirectory)
        } else {
            installationManager = try InstallationManager(gameDirectory: gameDirectory)
        }
        
        if let userRequestedVersion = version {
            installationManager.use(version: userRequestedVersion)
        } else {
            installationManager.useLatest()
        }

        // MARK: Version Info
        var versionInfoResult: Result<VersionPackage, CError> = .failure(.unknownError("Callback never completed"))
        let group = DispatchGroup()
        group.enter()
        installationManager.downloadVersionInfo { result in
            versionInfoResult = result
            group.leave()
        }
        group.wait()
        let versionInfo: VersionPackage
        switch versionInfoResult {
            case .success(let package):
                versionInfo = package
            case .failure(let error):
                Main.exit(withError: error)
        }
        
        guard versionInfo.minimumLauncherVersion >= 21 else {
            print("Unfortunately, \(versionInfo.id) isn't available from this utility")
            print("This utility is only tested with the latest version, and does not work with versions prior to 1.13")
            Main.exit()
        }
        
        group.enter()
        installationManager.downloadJar { result in
            switch result {
                case .failure(let error):
                    Main.exit(withError: error)
                default:
                    break
            }
            group.leave()
        }
        
        group.enter()
        installationManager.downloadAssets { result in
            switch result {
                case .failure(let error):
                    Main.exit(withError: error)
                default:
                    break                    
            }
            group.leave()
        }
        
        group.enter()
        installationManager.downloadLibraries { result in
            switch result {
                case .failure(let error):
                    Main.exit(withError: error)
                default:
                    break
            }
            group.leave()
        }
        
        print("Queued up downloads")
        group.wait()
        
        try installationManager.copyNatives()
                
        let launchArgumentsResults = installationManager.launchArguments(with: auth)
        switch launchArgumentsResults {
            case .success(let args):
                let proc = Process()
                proc.executableURL = URL(fileURLWithPath: "/usr/bin/java")
                proc.arguments = args
                proc.currentDirectoryURL = installationManager.baseDirectory
                
                let pipe = Pipe()
                proc.standardOutput = pipe
                
                print("Starting game...")
                proc.launch()
                
                proc.waitUntilExit()
            case .failure(let error):
                Main.exit(withError: error)
        }
        
    }
}
