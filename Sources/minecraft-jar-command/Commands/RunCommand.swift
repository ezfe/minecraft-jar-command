//
//  RunCommand.swift
//
//
//  Created by Ezekiel Elin on 11/21/20.
//

import Foundation
import MojangAuthentication
import ArgumentParser
import Common
import InstallationManager

struct RunCommand: ParsableCommand {
    static var configuration = CommandConfiguration(
        commandName: "run",
        abstract: "Run Minecraft"
    )
    
    @Option(help: "The Minecraft version to download")
    var version: String?
        
    @Flag(help: "Get the most recent snapshot versions of the game when a version isn't manually specified")
    var snapshot = false
    
    @Flag(help: "List available versions")
    var listVersions = false
    
    @Option(help: "The directory to save assets and libraries to")
    var workingDirectory: String?
    
    @Option(help: "The directory to start the game in")
    var gameDirectory: String?
    
    @Flag(help: "Use Mojang manifest (no ARM support)")
    var mojangManifest: Bool = false
    
    @Flag(help: "Print the working directory")
    var printWorkingDirectory: Bool = false
    
//    @Option(help: "Switch Java versions")
//    var javaExecutable = "/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/bin/java"
    
    /*
    @Flag(help: "Print out the new access token before running the game")
    var printAccessToken: Bool = false
    
    @Argument(help: """
        An access token can be obtained from a POST request to
        the Minecraft authentication system. Refer to wiki.vg
        for more information on the /authenticate endpoint:
        https://wiki.vg/Authentication#Authenticate

        You can also use the access token stored in launcher_profiles.json,
        a file generated by the regular Minecraft Launcher.
        """)
    var accessToken: String
    
    @Argument(help: """
        A client token can be obtained from a POST request to
        the Minecraft authentication system. Refer to wiki.vg
        for more information on the /authenticate endpoint:
        https://wiki.vg/Authentication#Authenticate

        You can also use the client token stored in launcher_profiles.json,
        a file generated by the regular Minecraft Launcher.
        """)
    var clientToken: String
     */
    
    mutating func run() async throws {
//        if !FileManager.default.fileExists(atPath: javaExecutable) {
//            print("You must install Java 8")
//            print("Recommended: Azul Zulu Java 8 LTS")
//            print("https://www.azul.com/downloads/?version=java-8-lts&os=macos&architecture=arm-64-bit&package=jdk")
//            print("Expected Java location: \(javaExecutable)")
//            MainCommand.exit()
//        }
        
        let defaults = UserDefaults.standard
        
        guard let accessToken = defaults.string(forKey: "accessToken") else {
            print("Please run the login command with the --save-credentials flag to save a new access token")
            MainCommand.exit()
        }
        guard let clientToken = defaults.string(forKey: "clientToken") else {
            print("Please run the login command with the --save-credentials flag to save a new client token")
            MainCommand.exit()
        }
        
        let auth = try AuthenticationManager.refresh(accessToken: accessToken, clientToken: clientToken)
        
        defaults.set(auth.clientToken, forKey: "clientToken")
        defaults.set(auth.accessToken, forKey: "accessToken")

        let manifestUrl: VersionManifest.ManifestUrls
        if mojangManifest {
            manifestUrl = .mojang
        } else {
            manifestUrl = .backblaze
        }

        
        let gameDirectory = self.gameDirectory != nil ? URL(fileURLWithPath: self.gameDirectory!) : nil
        
        let installationManager: InstallationManager
        if let workingDirectory = workingDirectory {
            installationManager = try InstallationManager(requestedDirectory: URL(fileURLWithPath: workingDirectory), gameDirectory: gameDirectory)
        } else {
            installationManager = try InstallationManager(gameDirectory: gameDirectory)
        }
        
        if printWorkingDirectory {
            print("Working Directory: \(installationManager.baseDirectory.absoluteString)")
        }
        
        if let userRequestedVersion = version {
            installationManager.use(version: .custom(userRequestedVersion))
        } else if snapshot {
            installationManager.use(version: .snapshot)
        } else {
            installationManager.use(version: .release)
        }
        
        do {
            // MARK: Version Info
            if listVersions {
                print("Finding available versions...")
                let versions = try await installationManager.availableVersions(manifestUrl)
                print("Available versions:")
                for version in versions {
                    print("\t\(version.id)")
                }
                MainCommand.exit()
            }
            
            let versionInfo = try await installationManager.downloadVersionInfo(manifestUrl)
            guard versionInfo.minimumLauncherVersion >= 21 else {
                print("Unfortunately, \(versionInfo.id) isn't available from this utility")
                print("This utility is only tested with the latest version, and does not work with versions prior to 1.13")
                MainCommand.exit()
            }

            try await installationManager.downloadJar()
            async let _ = try await installationManager.downloadJava(manifestUrl)
            async let _ = try await installationManager.downloadAssets()
            async let _ = try await installationManager.downloadLibraries()
        } catch let err {
            MainCommand.exit(withError: err)
        }

        print("Queued up downloads")
        
        try installationManager.copyNatives()
        
        let launchArgumentsResults = installationManager.launchArguments(with: auth)
        switch launchArgumentsResults {
            case .success(let args):
                // java
                let javaBundle = installationManager.javaBundle!
                let javaExec = javaBundle.appendingPathComponent("Contents/Home/bin/java", isDirectory: false)
                
                print("Game parameters...")
                let proc = Process()
                proc.executableURL = javaExec
                proc.arguments = args
                proc.currentDirectoryURL = installationManager.baseDirectory

                print(proc.executableURL!.path)
                print(proc.arguments)
                print(proc.currentDirectoryURL!.path)
                
                let pipe = Pipe()
                proc.standardOutput = pipe

                print("Starting game...")
                proc.launch()

                proc.waitUntilExit()
            case .failure(let error):
                MainCommand.exit(withError: error)
        }
        
    }
}
